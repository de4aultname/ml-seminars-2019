\documentclass[specialist,
               substylefile = spbu.rtx,
               subf,href,colorlinks=true, 12pt]{disser}

\usepackage[unicode, pdftex]{hyperref}
\usepackage[a4paper, mag=1000, includefoot, left=3cm, right=1.5cm, top=2cm, bottom=2cm, headsep=1cm, footskip=1cm]{geometry}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{mathtools}

\ifpdf\usepackage{epstopdf}\fi
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{csvsimple}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{bm}

% Цвета для гиперссылок
%\definecolor{linkcolor}{HTML}{799B03}
%\definecolor{urlcolor}{HTML}{799B03}

%\hypersetup{pdfstartview=FitH, linkcolor=linkcolor, urlcolor=urlcolor, colorlinks=true}

\renewcommand{\labelenumii}{\theenumii)} % Перенумерация в enumerate
% Точка с запятой в качестве разделителя между номерами цитирований
%\setcitestyle{semicolon}

% Использовать полужирное начертание для векторов
\let\vec=\mathbf

% Включать подсекции в оглавление
\setcounter{tocdepth}{2}

\graphicspath{{fig/}}

\DeclareMathOperator{\argmax}{argmax}
\DeclareMathOperator{\argmin}{argmin}
\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\df}{df}
\DeclareMathOperator{\var}{Var}
\DeclareMathOperator{\tr}{tr}

\DeclareMathOperator{\T}{T}
\DeclareMathOperator{\Tr}{Tr} 
\DeclareMathOperator{\MSE}{MSE} 
\DeclareMathOperator{\E}{E}
\DeclareMathOperator{\D}{D}
\DeclareMathOperator{\Laplace}{L}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{corollary}{Следствие}
\newtheorem{statement}{Утверждение}
\newtheorem{remark}{Замечание}
\newtheorem{theorem+}{Теорема Гаусса-Маркова}
\newtheorem{proposition}{Предложение}


\newtheorem{definition}{Определение}
%\newtheorem{theorem}{Теорема}
%\newtheorem{proof}{Доказательство}


%----------------------------------------------------------------

\begin{document}
    
    \thispagestyle{empty}
    %
    \begin{center}
        Санкт-Петербургский государственный университет \\
        \vspace{0.3cm}	
        Прикладная математика и информатика \\
        \vspace{0.3cm}
        Кафедра статистического моделирования \\
        
        \vspace{6cm}			   	
        
        \vspace{0.3cm}	
        %\vspace{2cm}	
        {\huge Композиция методов. Бустинг.} \\
        \vspace{0.5cm}
        Романова Елизавета \\
        Горбачук Анна \\
        Сидоренко Денис \\
        
        \vspace{10cm}	
        
        Санкт-Петербург \\
        2019
    \end{center}
    
    \newpage
    
    
    \tableofcontents
    
    \newpage

\intro
Пусть мы всё также находимся в рамках терминов задачи 
обучения с учителем. То есть в общем случае также наблюдается некоторый отклик $Y$, который в случае классификации принимает значения из $\{1, \dots, k\}$, где $k$ --- число классов. А в случае регрессии принимает вещественные значения. Также у нас имеется $p$ признаков $X_{1},\ldots,X_{p}$. По предположению между признаками и откликами есть некоторая зависимость, которую требуется найти.

К сожалению в ряде задач, имеющими сложные нелинейности часто оказывается, что одиночные алгоритмы восстановления функции зависимости между признаками и откликом не дают требуемого качества.

В своё время возникла простая идея композиции алгоритмов, которая сначала получила эмпирическое, а затем и теоретическое подтверждение.

\section{Постановка задачи}
    В общем определении, следуя стандартной постановке задаче, в бустинге вводят дополнительное пространство оценок $\mathrm{R}$, которое работает только с алгоритмами, представленными в виде: $a(x) = C(b(x))$, где функция $b: X\to R$ является алгоритмическим оператором, а функция $C: R\to Y$ --- решающим правилом. Введём изменённую по отношению к стандартной постановку задачи.
\begin{definition}
    Композицией $T$ алгоритмов $a_t(x) = C(b_t(x)), t = 1, \dots, T$ называется суперпозиция алгоритмических операторов $b_t: X\to R$, корректирующей операции $F: R^\mathrm{T}\to R$ и решающего правила 
    $$C: R\to Y: a(x) = C(F(b_1(x),\dots,b_T(x))), x \in X$$
\end{definition}
\begin{remark}
    Алгоритмы $a_1(x), \dots, a_T(x)$(а иногда и операторы $b_t$) называются базовыми. А $\mathcal{B}(\Theta) = \{b(.;\theta)|\theta \in \Theta \}$ --- параметризованное множество базовых алгоритмов.
    Выбор базового алгоритма: выбор такого $\theta \in \Theta$ и $b(x) = b(x; \theta) \in \mathcal{B}$.
\end{remark}

Корректирующее правило $F: Y^\mathrm{T} \to Y$ может комбинировать как ответы алгоритмов, так и в случае классификации "оценки" принадлежности определённым классам, а в случае одних и тех же алгоритмов --- усреднённые веса по алгоритму. %TODO: подумать на этот счёт.


\noindent Как правило в качестве базовых алгоритмов выступают:
1) Решающие деревья(неглубокие(2-8)) --- используются чаще всего;  
2) Пороговые правила(data stumps);  
3) Решающие "пни"(дерево глубины 1) на некоторых задачах дают результаты значительно выше своих более глубоких конкурентов.  

Задача: Подбор оптимальных(в смысле рассматриваемой функции потерь) базовых алгоритмов $\{b_t(x)\}_{t=1}^T$.

\section{Примеры}

\subsection{Примеры пространств оценок}
% TODO: сделать примеры красиво
\begin{enumerate}
    \item В задаче классификации на два класса: $Y = \{-1, 1\}$ в качестве пространства оценок обычно используется множество действительных чисел $R = \mathbb{R}$. В этом случае алгоритмические операторы называются вещественнозначными классификаторами: $C(b(x)) = \sign b(x)$. Пояснение: в данном случае предполагается, что ответы базовых алгоритмов больше 0 соответствует 1, а меньше 0 --- -1.
    \item В задаче классификации на $M$ классов, $ Y=\{1, \dots, M\}$, в качестве подпространства оценок обычно используется $R = \mathbb{R}^M$. Алгоритмический оператор $b(x)$ выдаёт вектор оценок принадлежности объекта $x$ каждому из классов, $b(x) = b^1(x), \dots, b^M(x)$.
    Решающее правило $C$ относит объект к тому классу, для которого оценка максимальна:
    %TODO: подумать как сделать подпись под argmax
    $C(b(x)) === C(b^1(x), \dots, b^M(x)) = \argmax_{y \in Y} b^y(x)$
    Пояснение: такой вид имеют байесовские алгоритмы классификации и метрические алгоритмы.
    \item В задачах регрессии множество $Y$ уже достаточно богато, обычно $Y = \mathbb R$, поэтому использовать решающее правило нет особого смысла. В этом случае обычно полагают $R = \mathbb R$, $C(b) \equiv b$.
    \item
\end{enumerate}

\subsection{Примеры корректирующих операций}

\begin{itemize}
    \item Простое голосование (Simple Voting):
    $$F(b_1(x), \ldots , b_T(x))= \frac{1}{T} \sum_{t=1}^{T} b_t(x), \quad x \in X.$$
    Пояснение: по сути означает усреднение всех предсказаний при регрессии или классификации, если ответ алгоритма - вероятность.
    Если ответ алгоритма классификации класс, то берётся класс, за который наиболее часто голосовали базовые алгоритмы.
    \item Взвешенное голосование (Weighted Voting):
    $$F(b_1(x), \ldots , b_T(x))= \sum_{t=1}^{T} \alpha_t b_t(x), \quad x \in X, \quad \alpha_t \in R.$$ Пояснение: имеет смысл только, когда в качестве голосований используются разные алгоритмы.
    
    \item Смесь алгоритмов (Mixture of Experts):
    $$F(b_1(x), \ldots , b_T(x))= \sum_{t=1}^{T} g_t(x)b_t(x), \quad x \in X, \quad g_t: X \to  \mathbb R.$$
\end{itemize}

\subsection{Взвешенное голосование}
Корректирующая операция $F$ может иметь параметры, настраиваемые по обучающей выборке, наряду с параметрами базовых алгоритмов.
Например, в линейной комбинации настраиваются веса $\alpha_t$ базовых алгоритмов: 
\begin{equation}\label{eq_2}
b(x) = F(b_1(x), \ldots , b_T(x))= \sum_{t=1}^{T} \alpha_t b_t(x), \quad x \in X, \quad \alpha_t \in R.   
\end{equation}

Если веса $\alpha_t$ неотрицательны и нормированы, $\sum_{t=1}^{T} \alpha_t = 1$, то композицию $(\ref{eq_2})$ называют \textbf{выпуклой комбинацией} базовых алгоритмов. 
\vspace{0.2cm}

В задачах классификации корректирующая операция $(\ref{eq_2})$ называется \textbf{взвешенным голосованием} (weighted voting).

\subsection{Пример с нейронной сетью}

Рассмотрим задачу классификации с двумя классами$Y = \{-1, +1\}$ и двухслойную нейронную сеть, принимающую на входе n-мерный вектор признаков $x = (x^1, \dots, x^n), x \in X = \mathbb{R}$:
$$a(x) = \sign (\sum_{t=1}^{T} w_t\sigma(\sum_{j=1}^{n}w_{jt}x^j))$$, где $T$ --- число нейронов скрытого слоя, $w_{jt}$ --- вес связи между $j$--м признаком и $t$--м нейроном скрытого слоя, $w_t$--вес связи между $t$--м нейроном скрытого слоя и выходным нейроном, $\sigma$ -- функция активации. Такая сеть может рассматриваться как композиция алгоритмических операторов вида $b_t(x) = \sigma(\sum_{j=1}^{n}w_{jt}x^j)$ с линейной корректирующей операцией $F(b_1, \dots, b_T) = \sum_{t=1}^{T}w_tb_t$ и решающим правилом $C(b) = \sign b.$

\subsection{Бустинг в задачах классификации}
Рассмотрим задачу классификации на два класса, $Y = \{-1, +1\}$. Допустим, что решающее правило фиксировано, $C(b) = sign(b)$, базовые алгоритмы возвращают ответы $-1, 0, +1$. 
\vspace{0.2cm}

Ответ $b_t(x) = 0$ означает, что базовый алгоритм $b_t$ отказывается от классификации объекта $x$, и ответ $b_t(x)$ не учитывается в композиции.
\vspace{0.2cm}

Искомая алгоритмическая композиция имеет вид:
\begin{equation}\label{eq_3}
a(x) = C(F(b_1(x), \ldots , b_T (x)) = sign \left(\sum_{t=1}^{T} \alpha_t b_t(x) \right), \quad x \in X.
\end{equation}

Определим функционал качества композиции как число ошибок, допускаемых ею на обучающей выборке:
\begin{equation}\label{eq_4}
Q_T =\sum_{i=1}^{n}\left[y_i \sum_{t=1}^{T} \alpha_t b_t(x_i) < 0\right].
\end{equation}

Для упрощения задачи минимизации функционала $Q_T$ введём две эвристики (не полностью математически обоснованные, но при этом практически полезные алгоритмы).
\vspace{0.2cm}

\textbf{Эвристика 1.} При добавлении в композицию слагаемого $\alpha_t b_t(x)$ оптимизируется только базовый алгоритм $b_t$ и коэффициент при нём $\alpha_t$, а все предыдущие слагаемые $\alpha_1 b_1(x), \ldots, \alpha_{t-1} b_{t-1}(x)$ полагаются фиксированными.
\vspace{0.2cm}

\textbf{Эвристика 2.} Пороговая функция потерь в функционале $Q_t$ аппроксимируется (заменяется) непрерывно дифференцируемой оценкой сверху.
\vspace{0.2cm}

Вторая эвристика широко используется в теории классификации. 

%В частности, логарифмическая функция связана с принципом максимума правдоподобия и применяется в нейронных сетях и логистической регрессии. Кусочно линейная аппроксимация связана с принципом максимизации зазора между классами и применяется в методе опорных векторов.

%Рассмотрим экспоненциальную аппроксимацию, которая исторически была самой первой.

\subsection{Аппроксимации}
    Прежде чем приступать к описанию алгоритма Adaboost следует сказать, что существует множество гладких(дифференцируемых) аппроксимаций пороговой функции потерь. Некоторые примеры:
    \begin{enumerate}
        \item $S(z) = 2(1+\exp^z)^{-1}$ --- сигмоидная;
        \item $L(z) = \log_{2}(1+\exp^{-z})$ --- логарифмическая;
        \item $(1-z)_+$ ---кусочно--линейная;
        \item $\exp^{-z}$ ---экспоненциальная;
        \item $(1-z^2)$ ---квадратичная.
    \end{enumerate}

\section{Adaboost}
При использовании экспоненциальной аппроксимации $[y_i b(x_i) < 0] \leq e^{?y_i b(x_i)}$ эти две эвристики приводят к алгоритму Adaboost.
\vspace{0.2cm}

Оценим функционал $Q_T$ сверху:
\begin{equation*}
Q_T \leq \widetilde {Q}_T =\sum_{i=1}^{n} \exp \left(-y_i \sum_{t=1}^{T} \alpha_t b_t(x_i) \right) =
\end{equation*}
\begin{equation*}
= -\sum_{i=1}^{n}  \underbrace{\exp \left(-y_i \sum_{t=1}^{T} \alpha_t b_t(x_i) \right)}_{\omega_i} e^{?y_i\alpha_T b_T(x_i)}.
\end{equation*}

Заметим, что введённые здесь веса объектов $\omega_i$ не зависят от $\alpha_T b_T$ и могут быть вычислены перед построением базового алгоритма $b_T$.

Введём вектор нормированных весов $\widetilde W^n = \widetilde{\omega}_1, \ldots, \widetilde{\omega}_n$, где $\widetilde{\omega}_i = \omega_i / \sum_{j=1}^{n} \omega_j$.
\vspace{0.2cm}

Определим два функционала качества алгоритма классификации $b$ на обучающей выборке  $X^n = (x_i,y_i)_{i=1}^n$ с нормированным вектором весов объектов $U^n = (u_1, \ldots , u_n)$: суммарный вес ошибочных (negative) классификаций $N(b; U^n)$ и суммарный вес правильных (positive) классификаций $P(b; U^n)$:
$$N(b; U^n) = \sum_{i=1}^{n} u_i [b(x_i)=-y_i],$$
$$P(b; U^n) = \sum_{i=1}^{n} u_i [b(x_i)=y_i].$$

Заметим, что $1 - N - P$ есть суммарный вес отказов от классификации. Если
отказов нет, то $N + P = 1$.   

\begin{theorem+}
    Пусть $\mathcal{B}$~--- достаточно богатое семейство базовых алгоритмов.
    Пусть для любого нормированного вектора весов $U^n$ существует алгоритм $b \in \mathcal{B}$, классифицирующий выборку хотя бы немного лучше, чем наугад: $P(b; U^n)>N(b; U^n)$.
    
    
    Тогда минимум функционала $\widetilde {Q}_T$ достигается при
    $$b_T = \arg \max \limits_{b \in \mathcal{B}} \sqrt{P(b; \widetilde{W}^n)}-\sqrt{N(b; \widetilde {W}^n)},$$
    $$a_t = \frac{1}{2} \ln \frac{P(b_t; \widetilde{W}^n)}{N(b_t; \widetilde{W}^n)}.$$
\end{theorem+}

\subsection{Алгоритм}

\textbf{Вход:} $X^n = (x_i,y_i)_{i=1}^n$ - обучающая выборка, $T$ - максимальное число базовых алгоритмов.
\vspace{0.2cm}

\textbf{Выход:} базовые алгоритмы и их веса $\alpha_t b_t$, $t = 1, \ldots, T$.
\vspace{0.2cm}

\begin{enumerate}
    \item инициализация весов объектов: 
    
    $\omega_i := 1/n$, $i = 1, \ldots, n$;
    \item для всех $t=1,\ldots,T$, пока не выполнен критерий остановки:
    \item   $\quad$обучить базовый алгоритм: 
    
    $b_t := \arg \min \limits_{b \in \mathcal{B}} N(b; W^n)$;
    \item   $\quad a_t := \frac{1}{2} \ln \frac{1-N(b_t; W^n)}{N(b_t; W^n)}$;
    \item   $\quad$пересчет весов объектов: 
    
    $\omega_i := \omega_i e^{?\alpha_t y_i b_t(x_i)}$, $i = 1, \ldots, n$;
    \item   $\quad$нормировка весов объектов: 
    
    $\omega_0 := \sum_{j=1}^{n} \omega_j$; $\omega_i:=\omega_i/\omega_0$, $i = 1, \ldots, n$.
\end{enumerate}

\subsection{Достоинства и недостатки}
\textbf{Достоинства}
\begin{itemize}
    \item Хорошая обобщающая способность. В реальных задачах (не всегда, но часто) удаётся строить композиции, превосходящие по качеству базовые алгоритмы.
    Обобщающая способность может улучшаться (в некоторых задачах) по мере
    увеличения числа базовых алгоритмов.
    \item Простота реализации.
    \item Накладные расходы бустинга невелики. Время построения композиции практически полностью определяется временем обучения базовых алгоритмов.
    \item Возможность идентифицировать выбросы. Это "наиболее трудные" объекты $x_i$, для которых в процессе наращивания композиции веса $\omega_i$ принимают наибольшие значения.
\end{itemize}

\textbf{Недостатки AdaBoost.}
\begin{itemize}
\item AdaBoost склонен к переобучению при наличии значительного уровня шума
в данных. 
\item AdaBoost требует достаточно длинных обучающих выборок. 
\item Бустинг может приводить к построению громоздких композиций, состоящих
из сотен алгоритмов. Такие композиции исключают возможность содержательной интерпретации, требуют больших объёмов памяти и существенных затрат времени.
\item Жадная стратегия последовательного добавления приводит к построению
неоптимального набора базовых алгоритмов.

\end{itemize}

\section{AnyBoost}

Возьмём $Y = \{-1;+1\}$, $b_t: X \to \mathbb{R}$, $C(b) = sign(b)$;

$\Laplace(M)$~--- функция потерь, гладкая функция отступа $M$;
\vspace{0.2cm}

$M_T(x_i) = y_i \sum_{t=1}^{T} \alpha_t b_t(x_i)$~--- отступ композиции на объекте $x_i$;
\vspace{0.2cm}

Оценка сверху для числа ошибок композиции:
$$Q_T \leq \widetilde {Q}_T =\sum_{i=1}^{n} \Laplace (M_{T-1}(x_i) + y_i \alpha_T b_T(x_i)) \to \min \limits_{\alpha, b \in \mathcal{B}}.$$

Рассмотрим функцию потерь $\Laplace$ как функцию параметра $\alpha_T$,
$$\lambda(\alpha_T) = \Laplace(M_{T-1}(x_i) + y_i \alpha_T b_T(x_i))$$
и линеаризуем её в окрестности значения  $\alpha_T = 0$, разложив в ряд Тейлора и отбросив старшие члены: $\lambda(\alpha_T) \approx \lambda(0) + \alpha_T \lambda'(0)$.

Это приведет к линеаризация функционала $\widetilde {Q}_T$ по $\alpha_T$:
$$\widetilde {Q}_T \approx \sum_{i=1}^{n} \Laplace (M_{T-1}(x_i)) - \alpha \sum_{i=1}^{n} \underbrace{ - \Laplace' (M_{T-1}(x_i))}_{\omega_i} y_i b(x_i) \to \min \limits_{b \in \mathcal{B}},$$
где $w_i$ — веса объектов.

\subsection{Принцип явной максимизации отступов.}
Минимизация линеаризованного $\widetilde {Q}_T$ при фиксированном $\alpha$:
$$\widetilde {Q}_T \approx \sum_{i=1}^{n} \Laplace (M_{T-1}(x_i)) - \alpha \sum_{i=1}^{n} \omega_i y_i b(x_i) \to \min \limits_{b \in \mathcal{B}}$$
приводит к принципу явной максимизации отступов (direct optimization of margin, DOOM):
$$\sum_{i=1}^{n} \omega_i y_i b(x_i) \to \max \limits_{b \in \mathcal{B}}.$$

Затем $\alpha$ определяется путём одномерной минимизации $\widetilde {Q}_T$.
\vspace{0.2cm}

Итерации этих двух шагов приводят к алгоритму AnyBoost.
\vspace{0.2cm}

\textbf{Замечание.} AnyBoost переходит в AdaBoost в частном случае,
при $b_t: X \to \{-1, 0, +1\}$ и $\Laplace (M) = e^{-M}$.

\textbf{Вход:} $X^n = (x_i,y_i)_{i=1}^n$ - обучающая выборка, $T$ - максимальное число базовых алгоритмов.
\vspace{0.2cm}

\textbf{Выход:} базовые алгоритмы и их веса $\alpha_t b_t$, $t = 1, \ldots, T$.
\vspace{0.2cm}

\begin{enumerate}
\item инициализация отступов: $M_i := 0$, $i = 1, \ldots, n$;
\item для всех $t=1,\ldots,T$, пока не выполнен критерий остановки:
\item  $\quad$вычислить веса объектов:

$\omega_i = -\Laplace'(M_i)$, $i = 1, \ldots, n$;
\item   $\quad$обучить базовый алгоритм согласно принципу DOOM: 
$b_t := \arg \max \limits_{b \in \mathcal{B}} \sum_{i=1}^{n} \omega_i y_i b(x_i)$;
\item   $\quad$решить задачу одномерной минимизации:
$a_t := \arg \max \limits_{\alpha} \sum_{i=1}^{n} \Laplace(M_i+\alpha b_t(x_i) y_i)$;
\item   $\quad$пересчет отступов: 

$M_i := M_i +\alpha b_t(x_i) y_i$; $i = 1, \ldots, n$.
\end{enumerate}

\section{Градиентный бустинг}
    
Ранее мы изучили бэггинг и случайные леса~--- подходы к построению композиций, которые
независимо обучают каждый базовый алгоритм по некоторому подмножеству обучающих данных.
При этом возникает ощущение, что мы используем возможности объединения алгоритмов
не в полную силу, и можно было бы строить их так, чтобы каждая следующая модель
исправляла ошибки предыдущих. Даже после рассмотренных AdaBoost и AnyBoost это ощущение не пропадало.
Ниже мы рассмотрим метод, который реализует эту идею~--- градиентный бустинг,
предложенный Фридманом~\cite{friedman01gbm}. Этот подход является наиболее популярным методом "из коробки" на сегодняшний день.

\section{Бустинг в задаче регрессии}\label{section:regBoost}
Рассмотрим задачу минимизации квадратичного функционала:
\[
\frac12
\sum_{i = 1}^{\ell}
(a(x_i) - y_i)^2
\to
\min_{a}
\]
Будем искать итоговый алгоритм в виде суммы~\emph{базовых моделей}~(weak learners)~$b_n(x)$:
\[
a_N(x)
=
\sum_{n = 1}^{N}
b_n(x),
\]
где базовые алгоритмы~$b_n$ принадлежат некоторому семейству~$\mathbb{A}$.

Построим первый базовый алгоритм:
\[
b_1(x)
:=
\argmin_{b \in \mathbb{A}}
\frac12
\sum_{i = 1}^{\ell}
(b(x_i) - y_i)^2
\]
Решение такой задачи не представляет трудностей для многих семейств алгоритмов.
Теперь мы можем посчитать остатки на каждом объекте~--- расстояния от ответа
нашего алгоритма до истинного ответа:
\[
s_i^{(1)} = y_i - b_1(x_i)
\]
Если прибавить эти остатки к ответам построенного алгоритма, то он не будет допускать
ошибок на обучающей выборке.
Значит, будет разумно построить второй алгоритм так, чтобы его ответы
были как можно ближе к остаткам:
\[
b_2(x)
:=
\argmin_{b \in \mathbb{A}}
\frac12
\sum_{i = 1}^{\ell}
(b(x_i) - s_i^{(1)})^2
\]

Каждый следующий алгоритм тоже будем настраивать на остатки предыдущих:
$$s_i^{(N)}
=
y_i - \sum_{n = 1}^{N - 1} b_n(x_i)
=
y_i
-
a_{N - 1}(x_i),
\qquad
i = 1, \dots, \ell;\\
$$
$$b_N(x)
:=
\argmin_{b \in \mathbb{A}}
\frac12
\sum_{i = 1}^{\ell}
(b(x_i) - s_i^{(N)})^2
$$

Описанный метод прост в реализации,
хорошо работает и может быть найден во многих библиотеках~---
например, в~\texttt{scikit-learn}.

Заметим, что остатки могут быть найдены как антиградиент функции потерь по ответу модели,
посчитанный в точке ответа уже построенной композиции:
\[
s_i^{(N)}
=
y_i
-
a_{N - 1}(x_i)
=
-
\left.
\frac{\partial}{\partial z}
\frac12
(z - y_i)^2
\right|_{z = a_{N - 1}(x_i)}
\]
Получается, что выбирается такой базовый алгоритм, который как можно
сильнее уменьшит ошибку композиции~--- это свойство вытекает из его близости
к антиградиенту функционала на обучающей выборке.
Попробуем разобраться с этим свойством подробнее, а также попытаемся обобщить его
на другие функции потерь.
%Это наблюдение наводит нас на мысль, что аналогичным образом
%можно было бы строить композиции, оптимизирующие и другие функции потерь~---
%достаточно заменить остатки~$z_i^{(N)}$ на градиент нужного функционала.
%Именно так и работает градиентный бустинг, о котором пойдет речь ниже.

%\subsubsection{Градиентный спуск в функциональном пространстве}
\section{Градиентный бустинг}
Пусть дана некоторая дифференцируемая функция потерь~$L(y, z)$.
Будем строить взвешенную сумму базовых алгоритмов:
\[
a_N(x)
=
\sum_{n = 0}^{N}
\gamma_n b_n(x)
\]
Заметим, что в композиции имеется начальный алгоритм~$b_0(x)$.
Как правило, коэффициент~$\gamma_0$ при нем берут равным единице,
а сам алгоритм выбирают очень простым, например:
\begin{itemize}
    \item нулевым~$b_0(x) = 0$;
    \item возвращающим самый популярный класс~(в задачах классификации):
    \[
    b_0(x) = \argmax_{y \in \mathbb{Y}} \sum_{i = 1}^{\ell} [y_i = y]
    \]
    \item возвращающим средний ответ~(в задачах регрессии):
    \[
    b_0(x) = \frac{1}{\ell} \sum_{i = 1}^{\ell} y_i
    \]
\end{itemize}

Допустим, мы построили композицию~$a_{N - 1}(x)$ из $N - 1$ алгоритма,
и хотим выбрать следующий базовый алгоритм~$b_N(x)$ так, чтобы как можно сильнее
уменьшить ошибку:
\[
\sum_{i = 1}^{\ell}
L(y_i, a_{N - 1}(x_i) + \gamma_N b_N(x_i))
\to
\min_{b_N, \gamma_N}
\]

Ответим в первую очередь на следующий вопрос: если бы в качестве алгоритма~$b_N(x)$ мы
могли выбрать совершенно любую функцию, то какие значения ей следовало бы принимать
на объектах обучающей выборки? Иными словами, нам нужно понять, какие числа~$s_1, \dots, s_\ell$
надо выбрать для решения следующей задачи:
\[
\sum_{i = 1}^{\ell}
L(y_i, a_{N - 1}(x_i) + s_i)
\to
\min_{s_1, \dots, s_\ell}
\]
Понятно, что можно требовать~$s_i = y_i - a_{N - 1}(x_i)$,
но такой подход никак не учитывает особенностей функции потерь~$L(y, z)$
и требует лишь точного совпадения предсказаний и истинных ответов.
Более разумно потребовать, чтобы сдвиг~$s_i$ был противоположен производной функции потерь
в точке~$z = a_{N - 1}(x_i)$:
\[
s_i
=
-
\left.
\frac{\partial L}{\partial z}
\right|_{z = a_{N - 1}(x_i)}
\]
В этом случае мы сдвинемся в сторону скорейшего убывания функции потерь.
Заметим, что вектор сдвигов~$s = (s_1, \dots, s_\ell)$ совпадает
с антиградиентом:
\[
\left(
-\left.
\frac{\partial L}{\partial z}
\right|_{z = a_{N - 1}(x_i)}
\right)_{i = 1}^{\ell}
=
-\nabla_z
\sum_{i = 1}^{\ell}
L(y_i, z_i)
\big|_{z_i = a_{N - 1}(x_i)}
\]
При таком выборе сдвигов~$s_i$ мы, по сути, сделаем один шаг градиентного спуска,
двигаясь в сторону наискорейшего убывания ошибки на обучающей выборке.
Отметим, что речь идет о градиентном спуске в $\ell$-мерном пространстве предсказаний алгоритма
на объектах обучающей выборки.
Поскольку вектор сдвига будет свой на каждой итерации, правильнее обозначать его как~$s_i^{(N)}$,
но для простоты будем иногда опускать верхний индекс.

Итак, мы поняли, какие значения новый алгоритм должен принимать на объектах обучающей выборки.
По данным значениям в конечном числе точек необходимо построить функцию, заданную на всем
пространстве объектов.
Это классическая задача обучения с учителем, которую мы уже хорошо умеем решать.
Один из самых простых функционалов~--- среднеквадратичная ошибка.
Воспользуемся им для поиска базового алгоритма, приближающего градиент функции потерь на обучающей выборке:
\[
b_N(x)
=
\argmin_{b \in \mathbb{A}}
\sum_{i = 1}^{\ell}
\left(
b(x_i) - s_i
\right)^2
\]
Отметим, что здесь мы оптимизируем квадратичную функцию потерь
независимо от функционала исходной задачи~--- вся информация о функции потерь~$L$
находится в антиградиенте~$s_i$,
а на данном шаге лишь решается задача аппроксимации функции по~$\ell$ точкам.
Разумеется, можно использовать и другие функционалы, но среднеквадратичной ошибки,
как правило, оказывается достаточно.
Ещё одна причина для использования среднеквадратичной ошибки состоит в том,
что от алгоритма требуется как можно точнее приблизить направление
наискорейшего убывания функционала~(то есть направление~$(s_i)_i$);
совпадение направлений вполне логично оценивать через косинус угла между ними,
который напрямую связан со среднеквадратичной ошибкой.

После того, как новый базовый алгоритм найден, можно подобрать коэффициент при нем
по аналогии с наискорейшим градиентным спуском:
\[
\gamma_N
=
\argmin_{\gamma \in \mathbb{R}}
\sum_{i = 1}^{\ell}
L(y_i, a_{N - 1}(x_i) + \gamma b_N(x_i))
\]

Описанный подход с аппроксимацией антиградиента базовыми алгоритмами
и называется градиентным бустингом.
Данный метод представляет собой поиск лучшей функции, восстанавливающей истинную зависимость
ответов от объектов, в пространстве всех возможных функций.
Ищем мы данную функцию с помощью <<псевдоградиентного>> спуска~---
каждый шаг делается вдоль направления, задаваемого некоторым базовым алгоритмом.
При этом сам базовый алгоритм выбирается так, чтобы как можно лучше приближать
антиградиент ошибки на обучающей выборке.




%Предположим сначала, что нам известно распределение на объектах
%и ответах~$p(x, y)$.
%В этом случае мы можем записать функционал среднего риска
%\[
%    \Phi(a)
%    =
%    \int_{\XX}
%    \int_{\YY}
%        p(x, y)
%        L(y, a(x))
%        dy dx
%    =
%    \EE_{x, y}
%        L(y, a(x))
%    =
%    \EE_x \Bigl[
%        \EE_y L(y, a(x))
%        \cond
%        x
%    \Bigr].
%\]
%Мы можем воспользоваться непараметрическим подходом и поставить задачу
%выбора наилучшего алгоритма~$a$ среди всех возможных функций от объектов.
%Минимизация функционала среднего риска эквивалентна минимизации условного матожидания
%в каждой точке:
%\[
%    \phi(a(x))
%    =
%    \EE_y [
%        L(y, a(x))
%        \cond
%        x
%    ]
%    \to
%    \min_{a(x)}
%\]
%Строить алгоритм будем с помощью градиентного спуска.
%Выберем первый алгоритм~$b_0$~(начальное приближение), после чего
%мы сможем сделать градиентный шаг:
%\[
%    a_1(x)
%    =
%    b_0(x)
%    -
%    \gamma_1
%    g^{(1)}(x),
%\]
%где
%\[
%    g^{(1)}(x)
%    =
%    \left.
%    \frac{
%        \partial \phi(a)
%    }{
%        \partial a
%    }
%    \right|_{a = b_0(x)}.
%\]
%Аналогично будет делаться и каждый следующий шаг:
%\begin{align*}
%    &g^{(N)}(x)
%    =
%    \left.
%    \frac{
%        \partial \phi(a)
%    }{
%        \partial a
%    }
%    \right|_{a = a_{N - 1}(x)};\\
%    &a_N(x)
%    =
%    a_{N - 1}(x)
%    -
%    \gamma_N
%    g^{(N)}(x).
%\end{align*}
%На каждом шаге коэффициент при градиенте находится из
%задачи одномерной оптимизации
%\[
%    \gamma_N
%    =
%    \argmin_{\gamma}
%        \Phi(a_{N - 1}(x) - \gamma g_N(x)),
%\]
%решение которой не должно представлять проблем~\footnote{
%    См., например, метод Брента.
%}.
%Также можно показать, что при выполнении определенных условий регулярности
%градиент можно вычислять по формуле:
%\[
%    g^{(N)}(x)
%    =
%    \EE_y \left[
%        \frac{
%            \partial L(y, a)
%        }{
%            \partial a
%        }
%        \cond
%        x
%    \right]_{a = a_{N - 1}(x)}.
%\]

%После~$N$ шагов градиентного спуска мы получим алгоритм~$a_N(x)$,
%представляющий собой сумму функций:
%\[
%    a_N(x)
%    =
%    \sum_{n = 0}^{N}
%        \gamma_n b_n(x),
%\]
%где
%\[
%    b_n(x)
%    =
%    -g^{(N)}(x).
%\]

%Таким образом, с помощью градиентного спуска мы построим композицию алгоритмов.
%Единственная проблема данного подхода состоит в том,
%что в большинстве случаев нам неизвестно распределение~$p(x, y)$,
%а значит, мы не можем записать функционал~$\Phi(a)$
%и проводить его оптимизацию.
%Мы можем работать лишь с эмпирической функцией потерь,
%вычисляющей ошибку на обучающей выборке:
%\[
%    Q(a)
%    =
%    \sum_{i = 1}^{\ell}
%        L(y_i, a(x_i)).
%\]
%В этом случае мы можем вычислить значения градиента лишь в точках из
%обучающей выборки:
%\[
%    g_{i}^{(N)}
%    =
%    \left.
%    \frac{
%        \partial L(y_i, a)
%    }{
%        \partial a
%    }
%    \right|_{a = a_{N - 1}(x_i)}.
%\]
%Чтобы сделать градиентный шаг и найти следующий базовый алгоритм,
%необходимо восстановить всю функцию~$g^{(N)}(x)$.
%Будем приближать ее алгоритмами из базового семейства~$\AA$.
%Более конкретно, будем настраивать следующий базовый
%алгоритм~$b_N$, оптимизируя квадратичные отклонения от антиградиентов
%в точках из обучающей выборки:
%\[
%    \sum_{i = 1}^{\ell}
%        (b(x) - (-g_i^{(N)}))^2
%    \to
%    \min_{b \in \AA}.
%\]
%Отметим, что здесь мы оптимизируем квадратичную функцию потерь
%независимо от функционала~$L$ исходной задачи~--- вся информация о функции потерь~$L$
%находится в градиенте~$g_i^{(N)}$,
%а на данном шаге лишь решается задача аппроксимации функции по~$\ell$ точкам.

%После того, как базовый алгоритм~$b_N$ найден,
%остается лишь найти коэффициент при нем:
%\[
%    \gamma_N
%    =
%    \argmin_{\gamma}
%    \sum_{i = 1}^{\ell}
%        L(y_i, a_{N - 1}(x_i) + \gamma b_N(x_i)).
%\]

\section{Регуляризация}
\paragraph{Сокращение шага.}
На практике оказывается, что градиентный бустинг очень быстро
строит композицию, ошибка которой на обучении выходит на асимптоту,
после чего начинает настраиваться на шум и переобучаться.
Это явление можно объяснить одной из двух причин:
\begin{itemize}
    \item Если базовые алгоритмы очень простые~(например, решающие деревья небольшой глубины),
    то они плохо приближают вектор антиградиента.
    По сути, добавление такого базового алгоритма будет соответствовать шагу вдоль направления,
    сильно отличающегося от направления наискорейшего убывания.
    Соответственно, градиентный бустинг может свестись к случайному блужданию в пространстве.
    \item Если базовые алгоритмы сложные~(например, глубокие решающие деревья),
    то они способны за несколько шагов бустинга идеально подогнаться под обучающую выборку~---
    что, очевидно, будет являться переобучением, связанным с излишней сложностью семейства алгоритмов.
\end{itemize}
Хорошо зарекомендовавшим себя способом решения данной проблемы
является~\emph{сокращение шага}: вместо перехода в оптимальную
точку в направлении антиградиента делается укороченный шаг
\[
a_N(x)
=
a_{N - 1}(x)
+
\eta
\gamma_N
b_N(x),
\]
где~$\eta \in (0, 1]$~--- темп обучения~\cite{friedman01gbm}.
Как правило, чем меньше темп обучения,
тем лучше качество итоговой композиции.
Сокращение шага, по сути, позволяет понизить доверие к направлению, восстановленному базовым алгоритмом.

Также следует обратить внимание на число итераций градиентного бустинга.
Хотя ошибка на обучении монотонно стремится к нулю, ошибка на контроле,
как правило, начинает увеличиваться после определенной итерации.
Оптимальное число итераций можно выбирать, например, по отложенной выборке
или с помощью кросс-валидации.

\paragraph{Стохастический градиентный бустинг.}
Еще одним способом улучшения качества градиентного бустинга
является внесение рандомизации в процесс обучения базовых
алгоритмов~\cite{friedman99stochastic}.
А именно, алгоритм~$b_N$ обучается не по всей выборке~$X$,
а лишь по ее случайному подмножеству~$X^{k} \subset X$.
В этом случае понижается уровень шума в обучении,
а также повышается эффективность вычислений.
Существует рекомендация брать подвыборки, размер которых вдвое меньше
исходной выборки.

\section{Функции потерь}
\subsection{Регрессия}
При вещественном целевом векторе, как правило, используют квадратичную функцию потерь,
формулы для которой уже были приведены в разделе~\ref{section:regBoost}.
Другой вариант~--- модуль отклонения~$L(y, z) = |y - z|$,
для которого антиградиент вычисляется по формуле
\[
s_i^{(N)}
=
-
\sign
(a_{N - 1}(x_i) - y_i).
\]

\subsection{Классификация}
%В задаче классификации с двумя классами~$\YY = \{+1, -1\}$
%разумным выбором является настройка функции~$p_+(x) \in [0, 1]$,
%возвращающей вероятность класса~$+1$.
%В этом случае мы можем измерить правдоподобие обучающей выборки при условии
%модели~$p_+(x)$:
%\[
%    P(p_+)
%    =
%    \prod_{i = 1}^{\ell}
%        p_+(x_i)^{[y_i = 1]}
%        (1 - p_+(x_i))^{[y_i = -1]}.
%\]
%Данное правдоподобие следует максимизировать.
%Гораздо удобнее минимизировать отрицательный логарифм правдоподобия:
%\begin{equation}
%\label{eq:nll}
%    -\sum_{i = 1}^{\ell} \left(
%        [y_i = 1] \log p_+(x_i)
%        +
%        [y_i = -1] \log(1 - p_+(x_i))
%    \right)
%    \to \min_{p_+(x)}.
%\end{equation}
%Такая задача крайне неудобна~--- нам нужно искать алгоритм~$p_+(x)$
%с ограничением, что его ответ лежит на отрезке~$[0, 1]$.
%Будем вместо этого искать алгоритм~$a(x) \in \RR$, возвращающий
%любые вещественные числа, который связан
%с вероятностью~${p_+(x)}$ через сигмоидную функцию:
%\[
%    p_+(x)
%    =
%    \frac{
%        1
%    }{
%        1 + \exp(-a(x))
%    }
%\]
%Соответственно, вероятность отрицательного класса задается формулой
%\[
%    p_-(x)
%    =
%    1 - p_+(x)
%    =
%    \frac{
%        1
%    }{
%        1 + \exp(a(x))
%    }
%\]
%Подставляя эти выражения в логарифм правдоподобия~\eqref{eq:nll}, получаем:
%\begin{align*}
%    -\sum_{i = 1}^{\ell} &\left(
%        -[y_i = 1]
%        \log(1 + \exp(-a(x_i)))
%        -
%        [y_i = -1]
%        \log(1 + \exp(a(x_i)))
%    \right)
%    =\\
%    &=
%    \sum_{i = 1}^{\ell}
%        \log(1 + \exp(-y_i a(x_i))).
%\end{align*}

В задаче классификации с двумя классами
разумным выбором является логистическая функция потерь,
с которой уже сталкивались при изучении линейных методов:
\[
L(y, z)
=
\log(
1 + \exp(-yz)
).
\]
Задача поиска базового алгоритма с ней принимает вид
\[
b_N
=
\argmin_{b \in \mathbb{A}}
\sum_{i = 1}^{\ell} \left(
b(x_i)
-
\frac{
    y_i
}{
    1 + \exp(
    y_i a_{N - 1}(x_i)
    )
}
\right)^2.
\]
%Легко показать, что алгоритм возвращает логарифм отношения оценок вероятностей классов:
%\[
%    a(x)
%    =
%    \frac{1}{2}
%    \log
%    \frac{p_+(x)}{1 - p_+(x)}.
%\]
%Оценки вероятностей классов вычисляются по формулам
%\begin{align*}
%    &\hat P(y = 1 \cond x)
%    =
%    \frac{
%        1
%    }{
%        1 + \exp(-a(x))
%    };\\
%    &\hat P(y = -1 \cond x)
%    =
%    \frac{
%        1
%    }{
%        1 + \exp(a(x))
%    }.
%\end{align*}

%\begin{vkProblem}
%    Как будет выглядеть задача поиска базового алгоритма~$b_N(x)$
%    в случае с логистической функцией потерь?
%\end{vkProblem}

%\begin{esSolution}
%    Найдем компоненты антиградиента~$s_i$:
%    \begin{equation}
%    \label{eq:logisticGrad}
%        s_i^{(N)}
%        =
%        -
%        \left.
%        \frac{\partial L(y_i, z)}{\partial z}
%        \right|_{z = a_{N - 1}(x_i)}
%        =
%        \frac{
%            y_i
%        }{
%            1 + \exp(
%                y_i a_{N - 1}(x_i)
%            )
%        }.
%    \end{equation}
%    Значит, задача поиска базового алгоритма примет вид
%    \[
%        b_N
%        =
%        \argmin_{b \in \AA}
%        \sum_{i = 1}^{\ell} \left(
%            b(x_i)
%            -
%            \frac{
%                y_i
%            }{
%                1 + \exp(
%                    y_i a_{N - 1}(x_i)
%                )
%            }
%        \right)^2.
%    \]
%\end{esSolution}

Логистическая функция потерь имеет интересную особенность,
связанную со взвешиванием объектов.
Заметим, что ошибка на~$N$-й итерации может быть записана как
\begin{align*}
Q(a_N)
&=
\sum_{i = 1}^{\ell}
\log \left(
1 + \exp(
-y_i a_N(x_i)
)
\right)
=\\
&=
\sum_{i = 1}^{\ell}
\log \left(
1
+
\exp(
-y_i a_{N - 1}(x_i)
)
\exp(
-y_i \gamma_N b_N(x_i)
)
\right).
\end{align*}
Если отступ~$y_i a_{N - 1}(x_i)$ на~$i$-м объекте большой положительный,
то данный объект не будет вносить практически никакого вклада в ошибку,
и может быть исключен из всех вычислений на текущей итерации
без потерь.
Таким образом, величина
\[
w_i^{(N)}
=
\exp(
-y_i a_{N - 1}(x_i)
)
\]
может служить мерой важности объекта~$x_i$ на~$N$-й итерации градиентного бустинга.

\section{Градиентный бустинг над деревьями}
Считается, что градиентный бустинг над решающими деревьями~---
один из самых универсальных и сильных методов машинного обучения,
известных на сегодняшний день.
В частности, на градиентном бустинге над деревьями основан~MatrixNet~---
алгоритм ранжирования компании Яндекс~\cite{yandex_slides}.

Вспомним, что решающее дерево разбивает все пространство на непересекающиеся области,
в каждой из которых его ответ равен константе:
\[
b_n(x)
=
\sum_{j = 1}^{J_n}
b_{nj}
[x \in R_j],
\]
где~$j = 1, \dots, J_n$~--- индексы листьев,
$R_j$~--- соответствующие области разбиения,
$b_{nj}$~--- значения в листьях.
Значит, на~$N$-й итерации бустинга композиция обновляется как
\[
a_N(x)
=
a_{N - 1}(x)
+
\gamma_N
\sum_{j = 1}^{J_N}
b_{Nj}
[x \in R_j]
=
a_{N - 1}(x)
+
\sum_{j = 1}^{J_N}
\gamma_N
b_{Nj}
[x \in R_j].
\]
Видно, что добавление в композицию одного дерева с~$J_N$ листьями равносильно
добавлению~$J_N$ базовых алгоритмов, представляющих собой предикаты вида~$[x \in R_j]$.
Если бы вместо общего коэффициента~$\gamma_N$ был свой коэффициент~$\gamma_{Nj}$
при каждом предикате, то мы могли бы его подобрать так, чтобы повысить качество композиции.
Если подбирать свой коэффициент~$\gamma_{Nj}$ при каждом слагаемом, то потребность в~$b_{Nj}$ отпадает,
его можно просто убрать:
\[
\sum_{i = 1}^{\ell}
L\left(
y_i,
a_{N - 1}(x_i)
+
\sum_{j = 1}^{J_N}
\gamma_{Nj}
[x \in R_j]
\right)
\to
\min_{\{\gamma_{Nj}\}_{j = 1}^{J_N}}.
\]
Поскольку области разбиения~$R_j$ не пересекаются,
данная задача распадается на~$J_N$ независимых подзадач:
\[
\gamma_{Nj}
=
\argmin_\gamma
\sum_{x_i \in R_j}
L(y_i, a_{N - 1}(x_i) + \gamma),
\qquad
j = 1, \dots, J_N.
\]

В некоторых случаях оптимальные коэффициенты могут быть найдены аналитически~---
например, для квадратичной и абсолютной ошибки.

%\begin{vkProblem}
%    Найдите оптимальные коэффициенты~$\{\gamma_{Nj}\}_{j = 1}^{J}$
%    для функционалов квадратичной и абсолютной ошибки.
%\end{vkProblem}

%\begin{esSolution}
%    Требуется решить задачи
%    \[
%        \sum_{x_i \in R_j}
%            (a_{N - 1}(x_i) + \gamma - y_i)^2
%        \to \min_\gamma
%    \]
%    и
%    \[
%        \sum_{x_i \in R_j}
%            |a_{N - 1}(x_i) + \gamma - y_i|
%        \to \min_\gamma.
%    \]

%    Известно, что решениями данных задач являются среднее и медиана остатков:
%    \begin{align*}
%        &\gamma_1
%        =
%        \frac{1}{|R_j|}
%        \sum_{x_i \in R_j}
%            (y_i - a_{N - 1}(x_i));\\
%        &\gamma_2
%        =
%        \median_{x_i \in R_j} \left\{
%            y_i - a_{N - 1}(x_i)
%        \right\}.
%    \end{align*}

%    Видно, что в случае с квадратичным функционалом дополнительную настройку коэффициентов можно не делать~---
%    деревья и так настраиваются на квадратичный функционал, и в листьях будет записано среднее значение
%    ответа по попавшим в них объектам.

%    В случае с абсолютной функцией потерь настройка коэффициентов уже несет в себе пользу.
%    Сами деревья настраиваются так, чтобы квадратичное отклонение
%    от знака ошибки было минимально~(т.е. минимизируется~$(b(x) - \sign(y_i - a_{N - 1}(x_i)))^2$),
%    но затем мы изменяем значения в листьях так, чтобы они были оптимальны с точки зрения
%    модуля отклонения.
%    Безусловно, дерево можно сразу настраивать на модули отклонений,
%    но такая процедура работает гораздо медленнее, чем настройка на квадратичные потери.
%\end{esSolution}

Рассмотрим теперь логистическую функцию потерь.
В этом случае нужно решить задачу
\[
F_j^{(N)}(\gamma)
=
\sum_{x_i \in R_j}
\log\left(
1 + \exp\left(
-y_i (a_{N - 1}(x_i) + \gamma)
\right)
\right)
\to
\min_{\gamma}.
\]
Данная задача может быть решена лишь с помощью итерационных методов,
аналитической записи для оптимального~$\gamma$ не существует.
Однако на практике обычно нет необходимости искать точное решение~---
оказывается достаточным сделать лишь один шаг метода Ньютона-Рафсона
из начального приближения~$\gamma_{Nj} = 0$.
Можно показать, что в этом случае
\[
\gamma_{Nj}
=
\frac{\partial F_j^{(N)}(0)}{\partial \gamma}
\Biggl/
\frac{\partial^2 F_j^{(N)}(0)}{\partial \gamma^2}
=
-
\sum_{x_i \in R_j}
s_i^{(N)}
\Biggl/
\sum_{x_i \in R_j}
|s_i^{(N)}| (1 - |s_i^{(N)}|).
\]

\paragraph{Смещение и разброс.}

В случайных лесах используются глубокие деревья, поскольку от базовых алгоритмов
требуется низкое смещение; разброс же устраняется за счёт усреднения ответов различных деревьев.
Бустинг работает несколько иначе~--- в нём каждый следующий алгоритм целенаправленно
понижает ошибку композиции, и даже при использовании простейших базовых моделей композиция может
оказаться достаточно сложной.
Более того, итоговая композиция вполне может оказаться переобученной при большом количестве
базовых моделей.
Это означает, что благодаря бустингу можно понизить смещение моделей, а разброс либо
останется таким же, либо увеличится.
Из-за этого, как правило, в бустинге используются неглубокие решающие деревья (3-6 уровней),
которые обладают большим смещением, но не склонны к переобучению.


\section{Взвешивание объектов}
Одним из первых широко распространённых методов построения композиций
является AdaBoost, в котором оптимизируется экспоненциальная функция потерь~$L(y, z) = e^{-yz}$.
Благодаря её свойствам удаётся свести задачу поиска базового алгоритма
к минимизации доли неверных ответов с весами при объектах.
Эти веса возникают и в градиентном бустинге при использовании экспоненциальной функции потерь:
\[
L(a, X)
=
\sum_{i = 1}^{\ell}
\exp\left(
-y_i
\sum_{n = 1}^{N}
\gamma_n
b_n(x_i)
\right).
\]
Найдем компоненты ее антиградиента после~$(N - 1)$-й итерации:
\[
s_i
=
-
\left.
\frac{\partial L(y_i, z)}{\partial z}
\right|_{z = a_{N - 1}(x_i)}
=
y_i
\underbrace{
    \exp\left(
    -y_i
    \sum_{n = 1}^{N - 1}
    \gamma_n b_n(x_i)
    \right)
}_{w_i}.
\]
Заметим, что антиградиент представляет собой
ответ на объекте, умноженный на его вес.
Если все веса будут равны единице, то следующий
базовый классификатор будет просто настраиваться на
исходный целевой вектор~$(y_i)_{i = 1}^{\ell}$;
штраф за выдачу ответа, противоположного правильному,
будет равен~$4$~(поскольку при настройке базового
алгоритма используется квадратичная функция потерь).
Если же какой-либо объект будет иметь большой отступ,
то его вес окажется близким к нулю,
и штраф за выдачу любого ответа будет равен~$1$.

Отметим, что многие функционалы ошибки классификации
выражаются через отступы объектов:
\[
L(a_{N - 1}, X^\ell)
=
\sum_{i = 1}^{\ell}
L(a_{N - 1}(x_i), y_i)
=
\sum_{i = 1}^{\ell}
\tilde
L(y_i a_{N - 1}(x_i)).
\]
В этом случае антиградиент принимает вид
\[
s_i
=
y_i
\underbrace{\left(
    -\frac{
        \partial \tilde L(y_i a_{N - 1}(x_i))
    }{
        \partial a_{N - 1}(x_i)
    }
    \right)}_{w_i},
\]
то есть тоже взвешивает ответы с помощью ошибки на них.

\section{Влияние шума на обучение}
Выше мы находили формулу для антиградиента при использовании
экспоненциальной функции потерь:
\[
s_i
=
y_i
\underbrace{
    \exp\left(
    -y_i
    \sum_{n = 1}^{N - 1}
    \gamma_n b_n(x_i)
    \right)
}_{w_i}.
\]
Заметим, что если отступ на объекте большой и отрицательный~(что обычно
наблюдается на шумовых объектах),
то вес становится очень большим,
причем он никак не ограничен сверху.
В результате базовый классификатор будет настраиваться
исключительно на шумовые объекты,
что может привести к неустойчивости его ответов и переобучению.

Рассмотрим теперь логистическую функцию потерь, которая
также может использоваться в задачах классификации:
\[
L(a, X^\ell)
=
\sum_{i = 1}^{\ell}
\log \left(
1
+
\exp\left(
-y_i a(x_i)
\right)
\right).
\]
Найдем ее антиградиент после~$(N - 1)$-го шага:
\[
s_i
=
y_i
\underbrace{
    \frac{
        1
    }{
        1
        +
        \exp(
        y_i a_{N - 1}(x_i)
        )
    }
}_{=w_i^{(N)}}.
\]
Теперь веса ограничены сверху единицей.
Если отступ на объекте большой отрицательный~(то есть это выброс),
то вес при нем будет близок к единице;
если же отступ на объекте близок к нулю~(то есть
это объект, на котором классификация неуверенная,
и нужно ее усиливать), то вес при нем будет примерно равен~$1/2$.
Таким образом, вес при шумовом объекте будет всего в два раза больше,
чем вес при нормальных объектах, что не должно
сильно повлиять на процесс обучения.

\section{Методы оптимизации второго порядка}
\emph{(дополнительный материал)}

Как мы выяснили выше, градиентный бустинг осуществляет градиентный спуск в пространстве
прогнозов алгоритма на обучающей выборке.
Здесь может возникнуть вполне логичный вопрос: а почему бы не воспользоваться другим,
более эффективным методом оптимизации?
Наиболее явными кандидатами являются методы оптимизации второго порядка~--- например, метод Ньютона.
При оптимизации числовой функции~$Q(w)$ шаг в методе Ньютона осуществляется по формуле
\[
w^{(n)}
=
w^{(n - 1)}
-
H^{-1}(w^{(n - 1)})
\nabla_w Q(w^{(n - 1)}),
\]
где~$H(w)$~--- матрица вторых производных, которая также называется матрицей Гессе.

Этим же подходом можно воспользоваться и в градиентном бустинге.
Нам нужно как можно сильнее уменьшить значение следующей функции путем подбора
сдвигов~$s_i$:
\[
Q(s)
=
\sum_{i = 1}^{\ell}
L(y_i, a_{N - 1}(x_i) + s_i)
\]
Мы уже находили вектор градиента:
\[
\nabla_s Q(s)
=
g
=
\left(
\left.
\frac{\partial L}{\partial z}
\right|_{z = a_{N - 1}(x_i)}
\right)_{i = 1}^{\ell}
\]
Заметим, что матрица вторых производных тут будет диагональной, поскольку
каждая переменная~$s_i$ входит лишь в одно отдельное слагаемое:
\[
H
=
\text{diag} \left(
\left.
\frac{\partial^2 L}{\partial z^2}
\right|_{z = a_{N - 1}(x_1)},
\dots,
\left.
\frac{\partial^2 L}{\partial z^2}
\right|_{z = a_{N - 1}(x_\ell)}
\right)
\]

Мы здесь пользуемся функционалом, который представляет собой сумму ошибок на всех объектах.
Такое представление подходит во многих задачах, но не является максимально общим.
Дело в том, что в некоторых ситуациях необходимо использовать функционалы,
которые измеряют качество сортировки объектов алгоритмом~--- это, иными словами,
функционалы качества ранжирования.
Их особенность заключается как раз в том, что матрица вторых производной уже не будет
диагональной.

Зная градиент и матрицу Гессе, мы можем выписать формулу для сдвигов~$s$:
\[
s
=
-H^{-1}
g
\]
Поскольку обращение матрицы является неустойчивой операцией, правильнее будет
находить вектор сдвигов через систему линейных уравнений
\[
Hs
=
-g
\]
В случае с диагональной матрицей Гессе данный подход сводится к домножению каждой компоненты
вектора антиградиента на некоторые коэффициенты.
В общем же случае такой подход может оказаться слишком сложным, поскольку при больших размерах выборки
матрица Гессе будет получаться слишком большой для эффективной работы.
После того, как рассчитан вектор сдвигов, процедура будет такой же, как и раньше~--- обучаем алгоритм
на данные сдвиги, находим коэффициент при нем, добавляем в композицию.

На похожей идее основан метод LogitBoost, который настраивает композицию с использованием логистической функции потерь,
исходя из несколько иных предположений.
Использование метода Ньютона приводит к тому, что базовый алгоритм настраивается на взвешенный функционал,
что может затруднять обучение.
Более того, формулы для весов получаются не вполне устойчивыми, и нередко в них происходит деление на очень маленькое число.
Чтобы избежать этого, вводится ряд достаточно грубых эвристик.

Обратим внимание, что трюк с переподбором прогнозов в листьях базовых решающих деревьев
похож на применение метода Ньютона.
Допустим, мы как-то выбрали сдвиги~$s_i$ и обучили на них решающее дерево~$b_n(x)$.
После этого на объекте~$x_i$ обучающей выборки будет сделан сдвиг~$b_n(x_i)$.
Сдвиги будут одинаковыми на тех объектах, которые попали в один и тот же лист дерева.
Если сделать переподбор, то сдвиги будут изменены так, чтобы как можно сильнее уменьшать
исходный функционал ошибки.
По сути, благодаря этому сдвиги подбираются индивидуально под группы объектов,
что близко к использованию методов второго порядка с диагональной матрицей Гессе~---
там тоже выставляются индивидуальные коэффициенты при компонентах сдвига.


\begin{thebibliography}{1}
    \bibitem{friedman01gbm}
    \emph{Friedman, Jerome H.} (2001).
    Greedy Function Approximation: A Gradient Boosting Machine.~//
    Annals of Statistics,
    29(5), p. 1189--1232.
    \bibitem{friedman99stochastic}
    \emph{Friedman, Jerome H.} (1999).
    Stochastic Gradient Boosting.~//
    Computational Statistics and Data Analysis,
    38, p. 367--378.
    \bibitem{yandex_slides}
    \emph{Gulin, A., Karpovich, P.} (2009).
    Greedy function optimization in learning to rank.\\
    \url{http://romip.ru/russir2009/slides/yandex/lecture.pdf}
\end{thebibliography}
\end{document}


\end{document}